#
# Autogenerated by Thrift Compiler (0.9.3)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException

from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class CrawlStatus:
  CRAWL_SUCCESS = 0
  CRAWL_FAILT = 1
  CRAWL_RobotsDisallow = 2
  CRAWL_RedirectExceedLimit = 3
  CRAWL_ConnectionFail = 4
  CRAWL_SizetooSmall = 5
  CRAWL_IdentifyFail = 6
  CRAWL_ProxyFail = 7
  CRAWL_ProxyDead = 8

  _VALUES_TO_NAMES = {
    0: "CRAWL_SUCCESS",
    1: "CRAWL_FAILT",
    2: "CRAWL_RobotsDisallow",
    3: "CRAWL_RedirectExceedLimit",
    4: "CRAWL_ConnectionFail",
    5: "CRAWL_SizetooSmall",
    6: "CRAWL_IdentifyFail",
    7: "CRAWL_ProxyFail",
    8: "CRAWL_ProxyDead",
  }

  _NAMES_TO_VALUES = {
    "CRAWL_SUCCESS": 0,
    "CRAWL_FAILT": 1,
    "CRAWL_RobotsDisallow": 2,
    "CRAWL_RedirectExceedLimit": 3,
    "CRAWL_ConnectionFail": 4,
    "CRAWL_SizetooSmall": 5,
    "CRAWL_IdentifyFail": 6,
    "CRAWL_ProxyFail": 7,
    "CRAWL_ProxyDead": 8,
  }


class SessionCommit:
  """
  Attributes:
   - refer_url
   - identifying_code_url
   - identifying_code_check_url
   - session_msg
   - check_body
   - check_body_not
   - need_identifying
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'refer_url', None, None, ), # 1
    (2, TType.STRING, 'identifying_code_url', None, None, ), # 2
    (3, TType.STRING, 'identifying_code_check_url', None, None, ), # 3
    (4, TType.MAP, 'session_msg', (TType.STRING,None,TType.STRING,None), None, ), # 4
    (5, TType.STRING, 'check_body', None, None, ), # 5
    (6, TType.STRING, 'check_body_not', None, None, ), # 6
    (7, TType.BOOL, 'need_identifying', None, False, ), # 7
  )

  def __init__(self, refer_url=None, identifying_code_url=None, identifying_code_check_url=None, session_msg=None, check_body=None, check_body_not=None, need_identifying=thrift_spec[7][4],):
    self.refer_url = refer_url
    self.identifying_code_url = identifying_code_url
    self.identifying_code_check_url = identifying_code_check_url
    self.session_msg = session_msg
    self.check_body = check_body
    self.check_body_not = check_body_not
    self.need_identifying = need_identifying

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.refer_url = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.identifying_code_url = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.identifying_code_check_url = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.MAP:
          self.session_msg = {}
          (_ktype1, _vtype2, _size0 ) = iprot.readMapBegin()
          for _i4 in xrange(_size0):
            _key5 = iprot.readString()
            _val6 = iprot.readString()
            self.session_msg[_key5] = _val6
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.check_body = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.check_body_not = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.BOOL:
          self.need_identifying = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SessionCommit')
    if self.refer_url is not None:
      oprot.writeFieldBegin('refer_url', TType.STRING, 1)
      oprot.writeString(self.refer_url)
      oprot.writeFieldEnd()
    if self.identifying_code_url is not None:
      oprot.writeFieldBegin('identifying_code_url', TType.STRING, 2)
      oprot.writeString(self.identifying_code_url)
      oprot.writeFieldEnd()
    if self.identifying_code_check_url is not None:
      oprot.writeFieldBegin('identifying_code_check_url', TType.STRING, 3)
      oprot.writeString(self.identifying_code_check_url)
      oprot.writeFieldEnd()
    if self.session_msg is not None:
      oprot.writeFieldBegin('session_msg', TType.MAP, 4)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.session_msg))
      for kiter7,viter8 in self.session_msg.items():
        oprot.writeString(kiter7)
        oprot.writeString(viter8)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.check_body is not None:
      oprot.writeFieldBegin('check_body', TType.STRING, 5)
      oprot.writeString(self.check_body)
      oprot.writeFieldEnd()
    if self.check_body_not is not None:
      oprot.writeFieldBegin('check_body_not', TType.STRING, 6)
      oprot.writeString(self.check_body_not)
      oprot.writeFieldEnd()
    if self.need_identifying is not None:
      oprot.writeFieldBegin('need_identifying', TType.BOOL, 7)
      oprot.writeBool(self.need_identifying)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.refer_url)
    value = (value * 31) ^ hash(self.identifying_code_url)
    value = (value * 31) ^ hash(self.identifying_code_check_url)
    value = (value * 31) ^ hash(self.session_msg)
    value = (value * 31) ^ hash(self.check_body)
    value = (value * 31) ^ hash(self.check_body_not)
    value = (value * 31) ^ hash(self.need_identifying)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Page:
  """
  Attributes:
   - url
   - compress_type
   - content
   - http_code
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'url', None, None, ), # 1
    (2, TType.I32, 'compress_type', None, None, ), # 2
    (3, TType.STRING, 'content', None, None, ), # 3
    (4, TType.I32, 'http_code', None, None, ), # 4
  )

  def __init__(self, url=None, compress_type=None, content=None, http_code=None,):
    self.url = url
    self.compress_type = compress_type
    self.content = content
    self.http_code = http_code

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.url = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.compress_type = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.content = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.http_code = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Page')
    if self.url is not None:
      oprot.writeFieldBegin('url', TType.STRING, 1)
      oprot.writeString(self.url)
      oprot.writeFieldEnd()
    if self.compress_type is not None:
      oprot.writeFieldBegin('compress_type', TType.I32, 2)
      oprot.writeI32(self.compress_type)
      oprot.writeFieldEnd()
    if self.content is not None:
      oprot.writeFieldBegin('content', TType.STRING, 3)
      oprot.writeString(self.content)
      oprot.writeFieldEnd()
    if self.http_code is not None:
      oprot.writeFieldBegin('http_code', TType.I32, 4)
      oprot.writeI32(self.http_code)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.url)
    value = (value * 31) ^ hash(self.compress_type)
    value = (value * 31) ^ hash(self.content)
    value = (value * 31) ^ hash(self.http_code)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Proxy:
  """
  Attributes:
   - host
   - port
   - user
   - password
   - type
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'host', None, None, ), # 1
    (2, TType.I32, 'port', None, None, ), # 2
    (3, TType.STRING, 'user', None, None, ), # 3
    (4, TType.STRING, 'password', None, None, ), # 4
    (5, TType.STRING, 'type', None, None, ), # 5
  )

  def __init__(self, host=None, port=None, user=None, password=None, type=None,):
    self.host = host
    self.port = port
    self.user = user
    self.password = password
    self.type = type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.host = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.port = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.user = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.password = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.type = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Proxy')
    if self.host is not None:
      oprot.writeFieldBegin('host', TType.STRING, 1)
      oprot.writeString(self.host)
      oprot.writeFieldEnd()
    if self.port is not None:
      oprot.writeFieldBegin('port', TType.I32, 2)
      oprot.writeI32(self.port)
      oprot.writeFieldEnd()
    if self.user is not None:
      oprot.writeFieldBegin('user', TType.STRING, 3)
      oprot.writeString(self.user)
      oprot.writeFieldEnd()
    if self.password is not None:
      oprot.writeFieldBegin('password', TType.STRING, 4)
      oprot.writeString(self.password)
      oprot.writeFieldEnd()
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.STRING, 5)
      oprot.writeString(self.type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.host is None:
      raise TProtocol.TProtocolException(message='Required field host is unset!')
    if self.port is None:
      raise TProtocol.TProtocolException(message='Required field port is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.host)
    value = (value * 31) ^ hash(self.port)
    value = (value * 31) ^ hash(self.user)
    value = (value * 31) ^ hash(self.password)
    value = (value * 31) ^ hash(self.type)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DownLoadReq:
  """
  Attributes:
   - url
   - method
   - download_type
   - ip_list
   - src_type
   - priority
   - retry_times
   - time_out
   - post_data
   - http_header
   - session_commit
   - verify
   - max_content_length
   - user
   - password
   - scheduler
   - parse_extends
   - data_extends
   - proxy
   - info
   - use_proxy
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'url', None, None, ), # 1
    (2, TType.STRING, 'method', None, "get", ), # 2
    (3, TType.STRING, 'download_type', None, "simple", ), # 3
    (4, TType.LIST, 'ip_list', (TType.STRING,None), None, ), # 4
    (5, TType.STRING, 'src_type', None, None, ), # 5
    (6, TType.I32, 'priority', None, None, ), # 6
    (7, TType.I32, 'retry_times', None, None, ), # 7
    (8, TType.I32, 'time_out', None, None, ), # 8
    (9, TType.MAP, 'post_data', (TType.STRING,None,TType.STRING,None), None, ), # 9
    (10, TType.MAP, 'http_header', (TType.STRING,None,TType.STRING,None), None, ), # 10
    (11, TType.STRUCT, 'session_commit', (SessionCommit, SessionCommit.thrift_spec), None, ), # 11
    (12, TType.BOOL, 'verify', None, False, ), # 12
    (13, TType.I32, 'max_content_length', None, None, ), # 13
    (14, TType.STRING, 'user', None, None, ), # 14
    (15, TType.STRING, 'password', None, None, ), # 15
    (16, TType.STRING, 'scheduler', None, None, ), # 16
    (17, TType.STRING, 'parse_extends', None, None, ), # 17
    (18, TType.STRING, 'data_extends', None, None, ), # 18
    (19, TType.STRUCT, 'proxy', (Proxy, Proxy.thrift_spec), None, ), # 19
    (20, TType.MAP, 'info', (TType.STRING,None,TType.STRING,None), {
    }, ), # 20
    (21, TType.BOOL, 'use_proxy', None, True, ), # 21
  )

  def __init__(self, url=None, method=thrift_spec[2][4], download_type=thrift_spec[3][4], ip_list=None, src_type=None, priority=None, retry_times=None, time_out=None, post_data=None, http_header=None, session_commit=None, verify=thrift_spec[12][4], max_content_length=None, user=None, password=None, scheduler=None, parse_extends=None, data_extends=None, proxy=None, info=thrift_spec[20][4], use_proxy=thrift_spec[21][4],):
    self.url = url
    self.method = method
    self.download_type = download_type
    self.ip_list = ip_list
    self.src_type = src_type
    self.priority = priority
    self.retry_times = retry_times
    self.time_out = time_out
    self.post_data = post_data
    self.http_header = http_header
    self.session_commit = session_commit
    self.verify = verify
    self.max_content_length = max_content_length
    self.user = user
    self.password = password
    self.scheduler = scheduler
    self.parse_extends = parse_extends
    self.data_extends = data_extends
    self.proxy = proxy
    if info is self.thrift_spec[20][4]:
      info = {
    }
    self.info = info
    self.use_proxy = use_proxy

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.url = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.method = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.download_type = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.ip_list = []
          (_etype12, _size9) = iprot.readListBegin()
          for _i13 in xrange(_size9):
            _elem14 = iprot.readString()
            self.ip_list.append(_elem14)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.src_type = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.priority = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.retry_times = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I32:
          self.time_out = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.MAP:
          self.post_data = {}
          (_ktype16, _vtype17, _size15 ) = iprot.readMapBegin()
          for _i19 in xrange(_size15):
            _key20 = iprot.readString()
            _val21 = iprot.readString()
            self.post_data[_key20] = _val21
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.MAP:
          self.http_header = {}
          (_ktype23, _vtype24, _size22 ) = iprot.readMapBegin()
          for _i26 in xrange(_size22):
            _key27 = iprot.readString()
            _val28 = iprot.readString()
            self.http_header[_key27] = _val28
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRUCT:
          self.session_commit = SessionCommit()
          self.session_commit.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.BOOL:
          self.verify = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.I32:
          self.max_content_length = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.STRING:
          self.user = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 15:
        if ftype == TType.STRING:
          self.password = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 16:
        if ftype == TType.STRING:
          self.scheduler = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 17:
        if ftype == TType.STRING:
          self.parse_extends = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 18:
        if ftype == TType.STRING:
          self.data_extends = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 19:
        if ftype == TType.STRUCT:
          self.proxy = Proxy()
          self.proxy.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 20:
        if ftype == TType.MAP:
          self.info = {}
          (_ktype30, _vtype31, _size29 ) = iprot.readMapBegin()
          for _i33 in xrange(_size29):
            _key34 = iprot.readString()
            _val35 = iprot.readString()
            self.info[_key34] = _val35
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 21:
        if ftype == TType.BOOL:
          self.use_proxy = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DownLoadReq')
    if self.url is not None:
      oprot.writeFieldBegin('url', TType.STRING, 1)
      oprot.writeString(self.url)
      oprot.writeFieldEnd()
    if self.method is not None:
      oprot.writeFieldBegin('method', TType.STRING, 2)
      oprot.writeString(self.method)
      oprot.writeFieldEnd()
    if self.download_type is not None:
      oprot.writeFieldBegin('download_type', TType.STRING, 3)
      oprot.writeString(self.download_type)
      oprot.writeFieldEnd()
    if self.ip_list is not None:
      oprot.writeFieldBegin('ip_list', TType.LIST, 4)
      oprot.writeListBegin(TType.STRING, len(self.ip_list))
      for iter36 in self.ip_list:
        oprot.writeString(iter36)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.src_type is not None:
      oprot.writeFieldBegin('src_type', TType.STRING, 5)
      oprot.writeString(self.src_type)
      oprot.writeFieldEnd()
    if self.priority is not None:
      oprot.writeFieldBegin('priority', TType.I32, 6)
      oprot.writeI32(self.priority)
      oprot.writeFieldEnd()
    if self.retry_times is not None:
      oprot.writeFieldBegin('retry_times', TType.I32, 7)
      oprot.writeI32(self.retry_times)
      oprot.writeFieldEnd()
    if self.time_out is not None:
      oprot.writeFieldBegin('time_out', TType.I32, 8)
      oprot.writeI32(self.time_out)
      oprot.writeFieldEnd()
    if self.post_data is not None:
      oprot.writeFieldBegin('post_data', TType.MAP, 9)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.post_data))
      for kiter37,viter38 in self.post_data.items():
        oprot.writeString(kiter37)
        oprot.writeString(viter38)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.http_header is not None:
      oprot.writeFieldBegin('http_header', TType.MAP, 10)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.http_header))
      for kiter39,viter40 in self.http_header.items():
        oprot.writeString(kiter39)
        oprot.writeString(viter40)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.session_commit is not None:
      oprot.writeFieldBegin('session_commit', TType.STRUCT, 11)
      self.session_commit.write(oprot)
      oprot.writeFieldEnd()
    if self.verify is not None:
      oprot.writeFieldBegin('verify', TType.BOOL, 12)
      oprot.writeBool(self.verify)
      oprot.writeFieldEnd()
    if self.max_content_length is not None:
      oprot.writeFieldBegin('max_content_length', TType.I32, 13)
      oprot.writeI32(self.max_content_length)
      oprot.writeFieldEnd()
    if self.user is not None:
      oprot.writeFieldBegin('user', TType.STRING, 14)
      oprot.writeString(self.user)
      oprot.writeFieldEnd()
    if self.password is not None:
      oprot.writeFieldBegin('password', TType.STRING, 15)
      oprot.writeString(self.password)
      oprot.writeFieldEnd()
    if self.scheduler is not None:
      oprot.writeFieldBegin('scheduler', TType.STRING, 16)
      oprot.writeString(self.scheduler)
      oprot.writeFieldEnd()
    if self.parse_extends is not None:
      oprot.writeFieldBegin('parse_extends', TType.STRING, 17)
      oprot.writeString(self.parse_extends)
      oprot.writeFieldEnd()
    if self.data_extends is not None:
      oprot.writeFieldBegin('data_extends', TType.STRING, 18)
      oprot.writeString(self.data_extends)
      oprot.writeFieldEnd()
    if self.proxy is not None:
      oprot.writeFieldBegin('proxy', TType.STRUCT, 19)
      self.proxy.write(oprot)
      oprot.writeFieldEnd()
    if self.info is not None:
      oprot.writeFieldBegin('info', TType.MAP, 20)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.info))
      for kiter41,viter42 in self.info.items():
        oprot.writeString(kiter41)
        oprot.writeString(viter42)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.use_proxy is not None:
      oprot.writeFieldBegin('use_proxy', TType.BOOL, 21)
      oprot.writeBool(self.use_proxy)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.url is None:
      raise TProtocol.TProtocolException(message='Required field url is unset!')
    if self.method is None:
      raise TProtocol.TProtocolException(message='Required field method is unset!')
    if self.download_type is None:
      raise TProtocol.TProtocolException(message='Required field download_type is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.url)
    value = (value * 31) ^ hash(self.method)
    value = (value * 31) ^ hash(self.download_type)
    value = (value * 31) ^ hash(self.ip_list)
    value = (value * 31) ^ hash(self.src_type)
    value = (value * 31) ^ hash(self.priority)
    value = (value * 31) ^ hash(self.retry_times)
    value = (value * 31) ^ hash(self.time_out)
    value = (value * 31) ^ hash(self.post_data)
    value = (value * 31) ^ hash(self.http_header)
    value = (value * 31) ^ hash(self.session_commit)
    value = (value * 31) ^ hash(self.verify)
    value = (value * 31) ^ hash(self.max_content_length)
    value = (value * 31) ^ hash(self.user)
    value = (value * 31) ^ hash(self.password)
    value = (value * 31) ^ hash(self.scheduler)
    value = (value * 31) ^ hash(self.parse_extends)
    value = (value * 31) ^ hash(self.data_extends)
    value = (value * 31) ^ hash(self.proxy)
    value = (value * 31) ^ hash(self.info)
    value = (value * 31) ^ hash(self.use_proxy)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DownLoadRsp:
  """
  Attributes:
   - url
   - redirect_url
   - src_type
   - status
   - http_code
   - download_time
   - elapsed
   - pages
   - content_type
   - content
   - page_size
   - scheduler
   - parse_extends
   - data_extends
   - info
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'url', None, None, ), # 1
    (2, TType.STRING, 'redirect_url', None, None, ), # 2
    (3, TType.STRING, 'src_type', None, None, ), # 3
    (4, TType.I32, 'status', None, None, ), # 4
    (5, TType.I32, 'http_code', None, None, ), # 5
    (6, TType.I32, 'download_time', None, None, ), # 6
    (7, TType.I32, 'elapsed', None, None, ), # 7
    (8, TType.LIST, 'pages', (TType.STRUCT,(Page, Page.thrift_spec)), None, ), # 8
    (9, TType.STRING, 'content_type', None, None, ), # 9
    (10, TType.STRING, 'content', None, None, ), # 10
    (11, TType.I32, 'page_size', None, None, ), # 11
    (12, TType.STRING, 'scheduler', None, None, ), # 12
    (13, TType.STRING, 'parse_extends', None, None, ), # 13
    (14, TType.STRING, 'data_extends', None, None, ), # 14
    (15, TType.MAP, 'info', (TType.STRING,None,TType.STRING,None), {
    }, ), # 15
  )

  def __init__(self, url=None, redirect_url=None, src_type=None, status=None, http_code=None, download_time=None, elapsed=None, pages=None, content_type=None, content=None, page_size=None, scheduler=None, parse_extends=None, data_extends=None, info=thrift_spec[15][4],):
    self.url = url
    self.redirect_url = redirect_url
    self.src_type = src_type
    self.status = status
    self.http_code = http_code
    self.download_time = download_time
    self.elapsed = elapsed
    self.pages = pages
    self.content_type = content_type
    self.content = content
    self.page_size = page_size
    self.scheduler = scheduler
    self.parse_extends = parse_extends
    self.data_extends = data_extends
    if info is self.thrift_spec[15][4]:
      info = {
    }
    self.info = info

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.url = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.redirect_url = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.src_type = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.status = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.http_code = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.download_time = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.elapsed = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.LIST:
          self.pages = []
          (_etype46, _size43) = iprot.readListBegin()
          for _i47 in xrange(_size43):
            _elem48 = Page()
            _elem48.read(iprot)
            self.pages.append(_elem48)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRING:
          self.content_type = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRING:
          self.content = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.I32:
          self.page_size = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.STRING:
          self.scheduler = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.STRING:
          self.parse_extends = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.STRING:
          self.data_extends = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 15:
        if ftype == TType.MAP:
          self.info = {}
          (_ktype50, _vtype51, _size49 ) = iprot.readMapBegin()
          for _i53 in xrange(_size49):
            _key54 = iprot.readString()
            _val55 = iprot.readString()
            self.info[_key54] = _val55
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DownLoadRsp')
    if self.url is not None:
      oprot.writeFieldBegin('url', TType.STRING, 1)
      oprot.writeString(self.url)
      oprot.writeFieldEnd()
    if self.redirect_url is not None:
      oprot.writeFieldBegin('redirect_url', TType.STRING, 2)
      oprot.writeString(self.redirect_url)
      oprot.writeFieldEnd()
    if self.src_type is not None:
      oprot.writeFieldBegin('src_type', TType.STRING, 3)
      oprot.writeString(self.src_type)
      oprot.writeFieldEnd()
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.I32, 4)
      oprot.writeI32(self.status)
      oprot.writeFieldEnd()
    if self.http_code is not None:
      oprot.writeFieldBegin('http_code', TType.I32, 5)
      oprot.writeI32(self.http_code)
      oprot.writeFieldEnd()
    if self.download_time is not None:
      oprot.writeFieldBegin('download_time', TType.I32, 6)
      oprot.writeI32(self.download_time)
      oprot.writeFieldEnd()
    if self.elapsed is not None:
      oprot.writeFieldBegin('elapsed', TType.I32, 7)
      oprot.writeI32(self.elapsed)
      oprot.writeFieldEnd()
    if self.pages is not None:
      oprot.writeFieldBegin('pages', TType.LIST, 8)
      oprot.writeListBegin(TType.STRUCT, len(self.pages))
      for iter56 in self.pages:
        iter56.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.content_type is not None:
      oprot.writeFieldBegin('content_type', TType.STRING, 9)
      oprot.writeString(self.content_type)
      oprot.writeFieldEnd()
    if self.content is not None:
      oprot.writeFieldBegin('content', TType.STRING, 10)
      oprot.writeString(self.content)
      oprot.writeFieldEnd()
    if self.page_size is not None:
      oprot.writeFieldBegin('page_size', TType.I32, 11)
      oprot.writeI32(self.page_size)
      oprot.writeFieldEnd()
    if self.scheduler is not None:
      oprot.writeFieldBegin('scheduler', TType.STRING, 12)
      oprot.writeString(self.scheduler)
      oprot.writeFieldEnd()
    if self.parse_extends is not None:
      oprot.writeFieldBegin('parse_extends', TType.STRING, 13)
      oprot.writeString(self.parse_extends)
      oprot.writeFieldEnd()
    if self.data_extends is not None:
      oprot.writeFieldBegin('data_extends', TType.STRING, 14)
      oprot.writeString(self.data_extends)
      oprot.writeFieldEnd()
    if self.info is not None:
      oprot.writeFieldBegin('info', TType.MAP, 15)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.info))
      for kiter57,viter58 in self.info.items():
        oprot.writeString(kiter57)
        oprot.writeString(viter58)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.url is None:
      raise TProtocol.TProtocolException(message='Required field url is unset!')
    if self.status is None:
      raise TProtocol.TProtocolException(message='Required field status is unset!')
    if self.http_code is None:
      raise TProtocol.TProtocolException(message='Required field http_code is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.url)
    value = (value * 31) ^ hash(self.redirect_url)
    value = (value * 31) ^ hash(self.src_type)
    value = (value * 31) ^ hash(self.status)
    value = (value * 31) ^ hash(self.http_code)
    value = (value * 31) ^ hash(self.download_time)
    value = (value * 31) ^ hash(self.elapsed)
    value = (value * 31) ^ hash(self.pages)
    value = (value * 31) ^ hash(self.content_type)
    value = (value * 31) ^ hash(self.content)
    value = (value * 31) ^ hash(self.page_size)
    value = (value * 31) ^ hash(self.scheduler)
    value = (value * 31) ^ hash(self.parse_extends)
    value = (value * 31) ^ hash(self.data_extends)
    value = (value * 31) ^ hash(self.info)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RetStatus:
  """
  Attributes:
   - status
   - errormessage
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'status', None, None, ), # 1
    (2, TType.STRING, 'errormessage', None, None, ), # 2
  )

  def __init__(self, status=None, errormessage=None,):
    self.status = status
    self.errormessage = errormessage

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.status = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.errormessage = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RetStatus')
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.I32, 1)
      oprot.writeI32(self.status)
      oprot.writeFieldEnd()
    if self.errormessage is not None:
      oprot.writeFieldBegin('errormessage', TType.STRING, 2)
      oprot.writeString(self.errormessage)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.status is None:
      raise TProtocol.TProtocolException(message='Required field status is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.status)
    value = (value * 31) ^ hash(self.errormessage)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
